# -*- coding: utf-8 -*-
"""Mnist_from_scratch.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18NxOidlHTjy6L70SEegrmDJNV2alBtHT
"""

# Commented out IPython magic to ensure Python compatibility.
# %reload_ext autoreload
# %autoreload 2
# %matplotlib inline

from fastai import *
from fastai.vision import *

path = untar_data(URLs.MNIST)
path.ls()

defaults.cmap = 'binary'

imglist = ImageList.from_folder(path,convert_mode = 'L')
imglist.items[0],imglist[0].show()

split = imglist.split_by_folder(train='training',valid = 'testing')
split

(path/'training').ls()

lbl = split.label_from_folder()
lbl

tfms = ([*rand_pad(padding=2,size=28,mode='reflection')],[])

data = lbl.transform(tfms).databunch(bs=128).normalize()

data.train_ds[0][0].show()

def _plot(x,y,ax):
  data.train_ds[5][0].show(ax,y=data.train_ds[5][1])

plot_multi(_plot,3,3,figsize=(10,10))

data.show_batch(3,figsize=(8,8))

def conv(n,m): return nn.Conv2d(n,m,kernel_size = 3,stride=2,padding=1)

model = nn.Sequential(
          conv(1,8), #14
          nn.BatchNorm2d(8),
          nn.ReLU(),
          conv(8,16), #7
          nn.BatchNorm2d(16),
          nn.ReLU(),
          conv(16,32), #4
          nn.BatchNorm2d(32),
          nn.ReLU(),
          conv(32,16), #2
          nn.BatchNorm2d(16),
          nn.ReLU(),
          conv(16,10), #1
          nn.BatchNorm2d(10),
          nn.Flatten()
)

learn = Learner(data,model,loss_func = nn.CrossEntropyLoss(), metrics=accuracy)

learn.lr_find()
learn.recorder.plot()

learn.fit_one_cycle(5)

def conv2(n,m) :
  return conv_layer(n,m,stride=2)

model = nn.Sequential(
        conv2(1,8),
        conv2(8,16),
        conv2(16,32),
        conv2(32,16),
        conv2(16,10),
        nn.Flatten()
)

learn = Learner(data,model,loss_func = nn.CrossEntropyLoss(), metrics=accuracy)

learn.fit_one_cycle(5)

print(learn.summary())

class Resblock(nn.Module):
  def __init__(self,n):
    super().__init__()
    self.conv1 = conv_layer(n,n)
    self.conv2 = conv_layer(n,n)
  
  def forward(self,x):
    return x + self.conv2(conv1(x))

model = nn.Sequential(
        conv2(1,8),
        Resblock(8),
        conv2(8,16),
        Resblock(16),
        conv2(16,32),
        Resblock(32),
        conv2(32,16),
        Resblock(16),
        conv2(16,10),
        nn.Flatten()
        
)

def conv_and_res(n,m):
  return nn.Sequential(conv2(n,m),res_block(m))

model = nn.Sequential(
          conv_and_res(1,8),
          conv_and_res(8,16),
          conv_and_res(16,32),
          conv_and_res(32,16),
          conv2(16,10),
          nn.Flatten()
)

learn = Learner(data,model,loss_func=nn.CrossEntropyLoss(),metrics=accuracy)

learn.lr_find()
learn.recorder.plot(end_lr = 100)

learn.fit_one_cycle(10,0.1)

print(learn.summary())

